using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Rendering;
using Unity.Transforms;
using UnityEngine;

namespace sora.TerraGen {
  /// <summary>
  /// Responsible for loading and unloading chunks at loacations that it's given.
  /// </summary>
  public sealed class TerrainGenerator : SystemBase {
    /// <summary>
    /// Information needed to load/generate a chunk.
    /// </summary>
    private struct LoadInfo {
      /// <summary>
      /// The entity that we are putting chunk data into.
      /// </summary>
      public Entity entity;

      /// <summary>
      /// The location of the chunk, in chunk space.
      /// </summary>
      public int3 location;
    }

    /// <summary>
    /// A place to store mesh information when created.
    /// </summary>
    private struct ChunkInfo {
      /// <summary>
      /// The mesh data generated by the meshing algorithm.
      /// </summary>
      public NativeList<float3> meshData;

      /// <summary>
      /// The volume data for the chunk generated.
      /// </summary>
      public NativeArray<float> volumeData;
    }

    /// <summary>
    /// A structure responsible for loading/generating chunk entity data.
    /// </summary>
    [BurstCompile]
    private struct ChunkJob : IJob {
      /// <summary>
      /// Information about the chunk entities that will be loaded/generated.
      /// </summary>
      [ReadOnly]
      public LoadInfo loadInfo;

      /// <summary>
      /// A place to store the results of generation.
      /// </summary>
      [WriteOnly]
      public ChunkInfo chunkInfo;

      /// <summary>
      /// The noise settings for a ChunkJob.
      /// </summary>
      public NoiseSettings noiseSettings;

      /// <summary>
      /// Executes the code necessary to loading/generating chunk entity data.
      /// </summary>
      /// <param name="index">
      /// The index of the job being performed.
      /// </param>
      public void Execute() {
        // Prep chunk data.
        var entity   = loadInfo.entity;
        var location = loadInfo.location;

        // Prep chunk generation.
        noiseSettings.offset = location * noiseSettings.size;
        noiseSettings.size  += 1;

        // Perform chunk generation.
        var noiseGenerator = new SimplexNoise(noiseSettings);
        var volumeData     = noiseGenerator.fractal3D();
        var meshData       = MarchingCubes.generate(volumeData, noiseSettings.size - 1, lod: 1);

        // Manually copy mesh data.
        for (int index = 0; index < meshData.Length; index++)
          chunkInfo.meshData.Add(meshData[index]);

        // Copy data and dispose of temporaries from callees.
        chunkInfo.volumeData.CopyFrom(volumeData);
        volumeData.Dispose();
        meshData.Dispose();
      }
    }

    /// <summary>
    /// The top level noise settings for chunk generation.
    /// </summary>
    public NoiseSettings noiseSettings;

    /// <summary>
    /// A list of chunks that need to be loaded/generated.
    /// </summary>
    public List<int3> chunksToLoad;

    /// <summary>
    /// A list of chunks that need to be unloaded.
    /// </summary>
    public List<int3> chunksToUnload;

    /// <summary>
    /// A mapping of a loaded chunk location to it's entity.
    /// </summary>
    private Dictionary<int3, Entity> mLoadedChunks;

    /// <summary>
    /// A list of the running chunk jobs.
    /// </summary>
    private List<ChunkJob> mRunningChunkJobs;

    /// <summary>
    /// A list of chunk jobs to complete.
    /// </summary>
    private List<JobHandle> mChunkJobHandles;

    /// <summary>
    /// The archetype for the entities created by the TerrainSystem.
    /// </summary>
    private EntityArchetype mChunkEntityArchetype;

    /// <summary>
    /// The material that chunks use.
    /// </summary>
    private Material mChunkMaterial;

    /// <summary>
    /// Called when a TerrainSystem object is created to make sure it is initialized inside of Unity.
    /// </summary>
    protected override void OnCreate() {
      // Initialize our collections.
      chunksToLoad      = new List<int3>();
      chunksToUnload    = new List<int3>();
      mLoadedChunks     = new Dictionary<int3, Entity>();
      mRunningChunkJobs = new List<ChunkJob>();
      mChunkJobHandles  = new List<JobHandle>();

      // Create chunk entity archetype.
      mChunkEntityArchetype = EntityManager.CreateArchetype(
        typeof(Translation),
        typeof(RenderMesh),
        typeof(RenderBounds),
        typeof(LocalToWorld),
        typeof(ChunkDataElement)
      );

      // Create material.
      mChunkMaterial = new Material(Shader.Find("Standard"));
    }

    /// <summary>
    /// Called when a TerrainSystem object needs to be updated by Unity, usually every frame.
    /// </summary>
    protected override void OnUpdate() {
      // Check if we can load chunks.
      if (chunksToLoad.Count > 0)
        scheduleChunksForLoad();

      // Handle the removal of completed jobs.
      removeCompletedJobs();
    }

    /// <summary>
    /// Performs the necessary operations to load/generate chunks.
    /// </summary>
    private void scheduleChunksForLoad() {
      sanitizeChunksToLoad();
      scheduleLoadingJobs();
      chunksToLoad.Clear();
    }

    /// <summary>
    /// Removes completed jobs.
    /// </summary>
    private void removeCompletedJobs() {
      // Get the indices to remove.
      var toRemove = new List<int>();
      int index    = 0;
      mChunkJobHandles.RemoveAll(item => {
        // Keep track of what iteration we are on.
        index++;

        // Do not remove this element.
        if (!item.IsCompleted)
          return false;

        // Because we are removing this element we need to reduce our index by 1.
        index--;

        // Get chunk job.
        var chunkJob  = mRunningChunkJobs[index];
        var loadInfo  = chunkJob.loadInfo;
        var chunkInfo = chunkJob.chunkInfo;

        // Complete job, add loaded chunk, and set loaded chunk data.
        item.Complete();
        mLoadedChunks.Add(loadInfo.location, loadInfo.entity);
        setLoadedChunkData(chunkInfo, loadInfo);

        // Do remove this element.
        mRunningChunkJobs.RemoveAt(index);
        return true;
      });
    }

    /// <summary>
    /// Sets the loaded chunk data for a chunk entity.
    /// </summary>
    /// <param name="chunkInfo">
    /// Contains the mesh and volume information for the chunk.
    /// </param>
    /// <param name="loadInfo">
    /// Contains the location and entity for the chunk.
    /// </param>
    private void setLoadedChunkData(ChunkInfo chunkInfo, LoadInfo loadInfo) {
      // Fill the chunk data buffer.
      var chunkDataBuffer = EntityManager.GetBuffer<ChunkDataElement>(loadInfo.entity);
      for (int index = 0; index < chunkInfo.volumeData.Length; index++) {
        // Set chunk data element.
        chunkDataBuffer.Add(new ChunkDataElement {
          voxel  = Voxel.Undefined,
          volume = chunkInfo.volumeData[index]
        });
      }

      // Set chunk mesh data.
      var meshDataSize = chunkInfo.meshData.Length;
      var mesh         = EntityManager.GetSharedComponentData<RenderMesh>(loadInfo.entity).mesh;
      var vertices     = new Vector3[meshDataSize];
      var triangles    = new int[meshDataSize];
      for (int dataIndex = 0; dataIndex < meshDataSize; dataIndex++) {
        vertices[dataIndex] = chunkInfo.meshData[dataIndex];
        triangles[dataIndex] = dataIndex;
      }

      // Set mesh data.
      mesh.vertices  = vertices;
      mesh.triangles = triangles;
      mesh.RecalculateNormals();
      mesh.OptimizeIndexBuffers();
      mesh.UploadMeshData(true);

      // Clean up our mess.
      chunkInfo.meshData.Dispose();
      chunkInfo.volumeData.Dispose();
    }

    /// <summary>
    /// Sanitizes the chunks to load so we aren't loading chunks that are already loaded.
    /// </summary>
    private void sanitizeChunksToLoad() {
      // Remove chunks that are already loaded.
      chunksToLoad.RemoveAll(item => mLoadedChunks.ContainsKey(item));
    }

    /// <summary>
    /// Schedules a single loading job based on the chunks to load.
    /// </summary>
    private void scheduleLoadingJobs() {
      // No need to try and process chunks if there are none.
      if (chunksToLoad.Count == 0)
        return;

      // Prep new entities.
      NativeArray<Entity> entities;
      createChunkEntities(out entities, chunksToLoad.Count);

      // Create and set load info.
      var noiseSize = noiseSettings.size + 1;
      var size      = noiseSize * noiseSize * noiseSize;
      for (int index = 0; index < chunksToLoad.Count; index++) {
        // Create loading info.
        var loadingInfo = new LoadInfo {
          entity   = entities[index],
          location = chunksToLoad[index]
        };

        // Create ChunkJob.
        var chunkJob = new ChunkJob {
          loadInfo = loadingInfo,
          chunkInfo = new ChunkInfo {
            meshData = new NativeList<float3>(Allocator.TempJob),
            volumeData = new NativeArray<float>(size, Allocator.TempJob, NativeArrayOptions.UninitializedMemory)
          },
          noiseSettings = noiseSettings
        };

        // Schedule.
        mChunkJobHandles.Add(chunkJob.Schedule());
        mRunningChunkJobs.Add(chunkJob);
      }
    }

    /// <summary>
    /// Creates new chunk entities and sets their data.
    /// </summary>
    /// <param name="entities">
    /// The entities that were created.
    /// </param>
    /// <param name="count">
    /// The number of entities to create.
    /// </param>
    private void createChunkEntities(out NativeArray<Entity> entities, int count) {
      // Set entities.
      entities = EntityManager.CreateEntity(mChunkEntityArchetype, count, Allocator.TempJob);

      // Set entity data.
      for (int index = 0; index < count; index++) {
        // Set chunk world position.
        EntityManager.SetComponentData(entities[index], new Translation {
          Value = chunksToLoad[index] * noiseSettings.size
        });

        // Set render bounds.
        EntityManager.SetComponentData(entities[index], new RenderBounds {
          Value = new AABB {
            Center  = new float3(0.0f, 0.0f, 0.0f),
            Extents = new float3(1.0f, 1.0f, 1.0f) * noiseSettings.size
          }
        });

        // Create chunk render mesh.
        EntityManager.SetSharedComponentData(entities[index], new RenderMesh {
          mesh           = new Mesh(),
          material       = mChunkMaterial,
          layer          = LayerMask.GetMask("Default"),
          // castShadows    = ShadowCastingMode.On,
          // receiveShadows = true
        });
      }
    }
  }
}
