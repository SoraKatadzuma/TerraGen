using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

namespace sora.TerraGen {
  /// <summary>
  /// Responsible for loading and unloading chunks at locations that it's given.
  /// </summary>
  public sealed partial class TerrainGenerator : SystemBase {
    /// <summary>
    /// A place to store mesh information when created.
    /// </summary>
    private struct ChunkInfo {
      /// <summary>
      /// The mesh data generated by the meshing algorithm.
      /// </summary>
      public NativeList<float3> meshData;

      /// <summary>
      /// The volume data for the chunk generated.
      /// </summary>
      public NativeArray<float> volumeData;
    }

    /// <summary>
    /// A structure responsible for loading/generating chunk entity data.
    /// </summary>
    [BurstCompile]
    private struct ChunkJob : IJob {
      /// <summary>
      /// Information about the chunk entities that will be loaded/generated.
      /// </summary>
      [ReadOnly]
      public int3 location;

      /// <summary>
      /// A place to store the results of generation.
      /// </summary>
      public ChunkInfo chunkInfo;

      /// <summary>
      /// The noise settings for a ChunkJob.
      /// </summary>
      public NoiseSettings noiseSettings;

      /// <summary>
      /// Executes the code necessary to loading/generating chunk entity data.
      /// </summary>
      public void Execute() {
        // Prep chunk generation.
        noiseSettings.offset = location * noiseSettings.size;
        noiseSettings.size  += 1;

        // Perform chunk generation.
        var volumeData = VolumeGenerator.GenerateData(noiseSettings);
        var meshData   = MarchingCubes.Generate(chunkInfo.volumeData, noiseSettings.size - 1, lod: 1);

        // Copy and dispose.
        chunkInfo.meshData.CopyFrom(meshData);
        chunkInfo.volumeData.CopyFrom(volumeData);
        meshData.Dispose();
        volumeData.Dispose();
      }
    }

    /// <summary>
    /// The top level noise settings for chunk generation.
    /// </summary>
    public NoiseSettings noiseSettings;

    /// <summary>
    /// A list of chunks that need to be loaded/generated.
    /// </summary>
    public List<int3> chunksToLoad;

    /// <summary>
    /// A list of chunks that need to be unloaded.
    /// </summary>
    public List<int3> chunksToUnload;

    /// <summary>
    /// A mapping of a loaded chunk location to it's entity.
    /// </summary>
    private Dictionary<int3, GameObject> mLoadedChunks;

    /// <summary>
    /// A List of waiting chunk jobs.
    /// </summary>
    private List<ChunkJob> mWaitingJobs;

    /// <summary>
    /// The currently running job.
    /// </summary>
    private ChunkJob mRunningChunkJob;

    /// <summary>
    /// A list of chunk jobs to complete.
    /// </summary>
    private JobHandle mChunkJobHandle;

    /// <summary>
    /// The material that chunks use.
    /// </summary>
    private Material mChunkMaterial;

    public static bool mFirstFrame = true;

    protected override void OnStartRunning() {
      //
    }

    /// <summary>
    /// Called when a TerrainSystem object is created to make sure it is initialized inside of Unity.
    /// </summary>
    protected override void OnCreate() {
      // Initialize our collections.
      chunksToLoad   = new List<int3>();
      chunksToUnload = new List<int3>();
      mLoadedChunks  = new Dictionary<int3, GameObject>();
      mWaitingJobs   = new List<ChunkJob>();

      // Create material.
      mChunkMaterial = new Material(Shader.Find("Standard"));
    }

    protected override void OnDestroy() {
      foreach (var job in mWaitingJobs) {
        job.chunkInfo.meshData.Dispose();
        job.chunkInfo.volumeData.Dispose();
      }
    }

    /// <summary>
    /// Called when a TerrainSystem object needs to be updated by Unity, usually every frame.
    /// </summary>
    protected override void OnUpdate() {
      // Check if we can load chunks.
      if (chunksToLoad.Count > 0)
        scheduleChunksForLoad();

      // Check if we can unload chunks.
      if (chunksToUnload.Count > 0)
        unloadChunks();

      // Check if first frame.
      if (mFirstFrame) {
        mFirstFrame = false;
        runNextJob();
        return;
      }

      // Check if job completed.
      if (!mChunkJobHandle.IsCompleted || mWaitingJobs.Count == 0)
        return;

      // Complete the running job and run next.
      completeRunningJob();
      runNextJob();
    }

    /// <summary>
    /// Performs the necessary operations to load/generate chunks.
    /// </summary>
    private void scheduleChunksForLoad() {
      sanitizeChunksToLoad();
      sanitizeWaitingJobs();
      queueLoadingJobs();
      chunksToLoad.Clear();
    }

    /// <summary>
    /// Unloads chunks at locations stored in the `chunksToUnload` member variable.
    /// </summary>
    private void unloadChunks() {
      // Iterate over each chunk to unload.
      chunksToUnload.RemoveAll(item => {
        // If this isn't even contained, remove it.
        if (!mLoadedChunks.ContainsKey(item))
          return true;

        // Get chunk entity and destroy it.
        var chunk = mLoadedChunks[item];

        // Destroy entity and remove loaded entry.
        GameObject.Destroy(chunk);
        mLoadedChunks.Remove(item);
        return true;
      });
    }

    /// <summary>
    /// Completes the running job.
    /// </summary>
    private void completeRunningJob() {
      // Complete job.
      mChunkJobHandle.Complete();

      // Get GameObject.
      var gameObject = new GameObject("Chunk" + mRunningChunkJob.location) {
        transform = {
          position = new float3(mRunningChunkJob.location * noiseSettings.size)
        },

        layer = LayerMask.NameToLayer("Terrain"),
        isStatic = true
      };

      // Add loaded chunk.
      mLoadedChunks.Add(mRunningChunkJob.location, gameObject);
      setLoadedChunkData(mRunningChunkJob.chunkInfo, gameObject);
    }

    /// <summary>
    /// Sets the loaded chunk data for a chunk entity.
    /// </summary>
    /// <param name="chunkInfo">
    /// Contains the mesh and volume information for the chunk.
    /// </param>
    /// <param name="chunkObject">
    /// The GameObject that we will populate to create and show the chunk.
    /// </param>
    private void setLoadedChunkData(ChunkInfo chunkInfo, GameObject chunkObject) {
      // Set chunk mesh data.
      var meshDataSize = chunkInfo.meshData.Length;
      var mesh         = chunkObject.AddComponent<MeshFilter>().mesh;
      chunkObject.AddComponent<MeshRenderer>().material = mChunkMaterial;
      chunkObject.AddComponent<MeshCollider>();

      var vertices  = new Vector3[meshDataSize];
      var triangles = new int[meshDataSize];
      for (var dataIndex = 0; dataIndex < meshDataSize; dataIndex++) {
        vertices[dataIndex]  = chunkInfo.meshData[dataIndex];
        triangles[dataIndex] = dataIndex;
      }

      // Set mesh data.
      mesh.vertices  = vertices;
      mesh.triangles = triangles;
      mesh.RecalculateNormals();
      mesh.OptimizeIndexBuffers();
      mesh.UploadMeshData(true);

      // Clean up our mess.
      chunkInfo.meshData.Dispose();
      chunkInfo.volumeData.Dispose();
    }

    /// <summary>
    /// Sanitizes the chunks to load so we aren't loading chunks that are already loaded.
    /// </summary>
    private void sanitizeChunksToLoad() {
      // Remove chunks that are already loaded.
      chunksToLoad.RemoveAll(item => mLoadedChunks.ContainsKey(item) || chunksToUnload.Contains(item));
    }

    /// <summary>
    /// Sanitizes the waiting jobs so we aren't attempting to load chunks that are to be unloaded.
    /// </summary>
    private void sanitizeWaitingJobs() {
      // Remove jobs whose locations should be unloaded.
      mWaitingJobs.RemoveAll(item => chunksToUnload.Contains(item.location));
    }

    /// <summary>
    /// Schedules a single loading job based on the chunks to load.
    /// </summary>
    private void queueLoadingJobs() {
      // No need to try and process chunks if there are none.
      if (chunksToLoad.Count == 0)
        return;

      // Create and set load info.
      var noiseSize = noiseSettings.size + 1;
      var size      = noiseSize * noiseSize * noiseSize;
      foreach (var t in chunksToLoad) {
        // Create ChunkJob.
        var chunkJob = new ChunkJob {
          location      = t,
          chunkInfo     = new ChunkInfo {
            meshData   = new NativeList<float3>(Allocator.TempJob),
            volumeData = new NativeArray<float>(size, Allocator.TempJob, NativeArrayOptions.UninitializedMemory)
          },
          noiseSettings = noiseSettings
        };

        // Add to waiting jobs.
        mWaitingJobs.Add(chunkJob);
      }
    }

    /// <summary>
    /// Sets the next job to run.
    /// </summary>
    private void runNextJob() {
      mRunningChunkJob = mWaitingJobs[0];
      mChunkJobHandle  = mRunningChunkJob.Schedule();
      mWaitingJobs.RemoveAt(0);
    }
  }
}
