using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Rendering;
using Unity.Transforms;
using UnityEngine;

namespace sora.TerraGen {
  /// <summary>
  /// Responsible for loading and unloading chunks at loacations that it's given.
  /// </summary>
  public sealed class TerrainGenerator : SystemBase {
    /// <summary>
    /// A place to store mesh information when created.
    /// </summary>
    private struct ChunkInfo {
      /// <summary>
      /// The mesh data generated by the meshing algorithm.
      /// </summary>
      public NativeList<float3> meshData;

      /// <summary>
      /// The volume data for the chunk generated.
      /// </summary>
      public NativeArray<float> volumeData;
    }

    /// <summary>
    /// A structure responsible for loading/generating chunk entity data.
    /// </summary>
    [BurstCompile]
    private struct ChunkJob : IJob {
      /// <summary>
      /// Information about the chunk entities that will be loaded/generated.
      /// </summary>
      [ReadOnly]
      public int3 location;

      /// <summary>
      /// A place to store the results of generation.
      /// </summary>
      [WriteOnly]
      public ChunkInfo chunkInfo;

      /// <summary>
      /// The noise settings for a ChunkJob.
      /// </summary>
      public NoiseSettings noiseSettings;

      /// <summary>
      /// Executes the code necessary to loading/generating chunk entity data.
      /// </summary>
      /// <param name="index">
      /// The index of the job being performed.
      /// </param>
      public void Execute() {
        // Prep chunk generation.
        noiseSettings.offset = location * noiseSettings.size;
        noiseSettings.size  += 1;

        // Perform chunk generation.
        var volumeData = VolumeGenerator.generateData(noiseSettings);
        var meshData   = MarchingCubes.generate(volumeData, noiseSettings.size - 1, lod: 1);

        // Manually copy mesh data.
        for (int index = 0; index < meshData.Length; index++)
          chunkInfo.meshData.Add(meshData[index]);

        // Copy data and dispose of temporaries from callees.
        chunkInfo.volumeData.CopyFrom(volumeData);
        volumeData.Dispose();
        meshData.Dispose();
      }
    }

    /// <summary>
    /// The top level noise settings for chunk generation.
    /// </summary>
    public NoiseSettings noiseSettings;

    /// <summary>
    /// A list of chunks that need to be loaded/generated.
    /// </summary>
    public List<int3> chunksToLoad;

    /// <summary>
    /// A list of chunks that need to be unloaded.
    /// </summary>
    public List<int3> chunksToUnload;

    /// <summary>
    /// A mapping of a loaded chunk location to it's entity.
    /// </summary>
    private Dictionary<int3, GameObject> mLoadedChunks;

    /// <summary>
    /// A list of the running chunk jobs.
    /// </summary>
    private List<ChunkJob> mRunningChunkJobs;

    /// <summary>
    /// A list of chunk jobs to complete.
    /// </summary>
    private List<JobHandle> mChunkJobHandles;

    /// <summary>
    /// The material that chunks use.
    /// </summary>
    private Material mChunkMaterial;

    /// <summary>
    /// Called when a TerrainSystem object is created to make sure it is initialized inside of Unity.
    /// </summary>
    protected override void OnCreate() {
      // Initialize our collections.
      chunksToLoad      = new List<int3>();
      chunksToUnload    = new List<int3>();
      mLoadedChunks     = new Dictionary<int3, GameObject>();
      mRunningChunkJobs = new List<ChunkJob>();
      mChunkJobHandles  = new List<JobHandle>();

      // Create material.
      mChunkMaterial = new Material(Shader.Find("Standard"));
    }

    /// <summary>
    /// Called when a TerrainSystem object needs to be updated by Unity, usually every frame.
    /// </summary>
    protected override void OnUpdate() {
      // Check if we can load chunks.
      if (chunksToLoad.Count > 0)
        scheduleChunksForLoad();

      // Check if we can unload chunks.
      if (chunksToUnload.Count > 0)
        unloadChunks();

      // Handle the removal of completed jobs.
      removeCompletedJobs();
    }

    /// <summary>
    /// Performs the necessary operations to load/generate chunks.
    /// </summary>
    private void scheduleChunksForLoad() {
      sanitizeChunksToLoad();
      scheduleLoadingJobs();
      chunksToLoad.Clear();
    }

    /// <summary>
    /// Unloads chunks at locations stored in the `chunksToUnload` member variable.
    /// </summary>
    private void unloadChunks() {
      // Iterate over each chunk to unload.
      chunksToUnload.RemoveAll(item => {
        // If this isn't even contained, remove it.
        if (!mLoadedChunks.ContainsKey(item))
          return true;

        // Get chunk entity and destory it.
        var chunk = mLoadedChunks[item];

        // Destroy entity and remove loaded entry.
        GameObject.Destroy(chunk);
        mLoadedChunks.Remove(item);
        return true;
      });
    }

    /// <summary>
    /// Removes completed jobs.
    /// </summary>
    private void removeCompletedJobs() {
      // Get the indices to remove.
      var toRemove = new List<int>();
      int index    = 0;
      mChunkJobHandles.RemoveAll(item => {
        // Keep track of what iteration we are on.
        index++;

        // Do not remove this element.
        if (!item.IsCompleted)
          return false;

        // Because we are removing this element we need to reduce our index by 1.
        index--;

        // Get chunk job.
        var chunkJob  = mRunningChunkJobs[index];
        var chunkInfo = chunkJob.chunkInfo;

        // Complete job, add loaded chunk, and set loaded chunk data.
        item.Complete();
        var gameObject = new GameObject("Chunk");
            gameObject.transform.position = new float3(chunkJob.location * noiseSettings.size);
        mLoadedChunks.Add(chunkJob.location, gameObject);
        setLoadedChunkData(chunkInfo, gameObject);

        // Do remove this element.
        mRunningChunkJobs.RemoveAt(index);
        return true;
      });
    }

    /// <summary>
    /// Sets the loaded chunk data for a chunk entity.
    /// </summary>
    /// <param name="chunkInfo">
    /// Contains the mesh and volume information for the chunk.
    /// </param>
    /// <param name="loadInfo">
    /// Contains the location and entity for the chunk.
    /// </param>
    private void setLoadedChunkData(ChunkInfo chunkInfo, GameObject chunkObject) {
      // Set chunk mesh data.
      var meshDataSize = chunkInfo.meshData.Length;
      var mesh         = chunkObject.AddComponent<MeshFilter>().mesh;
      var renderer     = chunkObject.AddComponent<MeshRenderer>().material = mChunkMaterial;
      var vertices     = new Vector3[meshDataSize];
      var triangles    = new int[meshDataSize];
      for (int dataIndex = 0; dataIndex < meshDataSize; dataIndex++) {
        vertices[dataIndex]  = chunkInfo.meshData[dataIndex];
        triangles[dataIndex] = dataIndex;
      }

      // Set mesh data.
      mesh.vertices  = vertices;
      mesh.triangles = triangles;
      mesh.RecalculateNormals();
      mesh.OptimizeIndexBuffers();
      mesh.UploadMeshData(true);

      // Clean up our mess.
      chunkInfo.meshData.Dispose();
      chunkInfo.volumeData.Dispose();
    }

    /// <summary>
    /// Sanitizes the chunks to load so we aren't loading chunks that are already loaded.
    /// </summary>
    private void sanitizeChunksToLoad() {
      // Remove chunks that are already loaded.
      chunksToLoad.RemoveAll(item => mLoadedChunks.ContainsKey(item));
    }

    /// <summary>
    /// Schedules a single loading job based on the chunks to load.
    /// </summary>
    private void scheduleLoadingJobs() {
      // No need to try and process chunks if there are none.
      if (chunksToLoad.Count == 0)
        return;

      // Create and set load info.
      var noiseSize = noiseSettings.size + 1;
      var size      = noiseSize * noiseSize * noiseSize;
      for (int index = 0; index < chunksToLoad.Count; index++) {
        // Create ChunkJob.
        var chunkJob = new ChunkJob {
          location = chunksToLoad[index],
          chunkInfo = new ChunkInfo {
            meshData = new NativeList<float3>(Allocator.TempJob),
            volumeData = new NativeArray<float>(size, Allocator.TempJob, NativeArrayOptions.UninitializedMemory)
          },
          noiseSettings = noiseSettings
        };

        // Schedule.
        mChunkJobHandles.Add(chunkJob.Schedule());
        mRunningChunkJobs.Add(chunkJob);
      }
    }
  }
}
